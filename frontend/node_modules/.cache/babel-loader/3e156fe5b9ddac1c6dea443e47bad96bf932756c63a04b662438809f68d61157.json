{"ast":null,"code":"import \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport { defineComponent, mergeModels, useAttrs, useSlots, useModel, inject, useTemplateRef, computed, openBlock, createBlock, mergeProps, unref, withCtx, withDirectives, createElementVNode, vModelCheckbox, createElementBlock, normalizeClass, renderSlot, createCommentVNode, provide, toRef, Fragment, renderList, createTextVNode, toDisplayString } from \"vue\";\nimport { c as useFocus } from \"./index-BgXbxfV9.mjs\";\nimport { g as getClasses, a as getInputClasses, b as getLabelClasses, c as getGroupAttr, d as getGroupClasses } from \"./useFormCheck-Bcx8Ea7M.mjs\";\nimport { i as checkboxGroupKey } from \"./keys-CsqIkltC.mjs\";\nimport { _ as _sfc_main$2 } from \"./ConditionalWrapper.vue_vue_type_script_lang-CUX3HBqw.mjs\";\nimport { i as isEmptySlot } from \"./dom-DSGRrOAo.mjs\";\nimport { u as useDefaults } from \"./useDefaults-dJMhLizZ.mjs\";\nimport { u as useId } from \"./useId-BR0P33VS.mjs\";\nconst _hoisted_1$1 = [\"id\", \"disabled\", \"required\", \"name\", \"form\", \"aria-label\", \"aria-labelledby\", \"aria-required\", \"value\", \"true-value\", \"false-value\", \"indeterminate\"];\nconst _hoisted_2 = [\"for\"];\nconst _sfc_main$1 = /* @__PURE__ */defineComponent({\n  ...{\n    inheritAttrs: false\n  },\n  __name: \"BFormCheckbox\",\n  props: /* @__PURE__ */mergeModels({\n    ariaLabel: {\n      default: void 0\n    },\n    ariaLabelledby: {\n      default: void 0\n    },\n    autofocus: {\n      type: Boolean,\n      default: false\n    },\n    button: {\n      type: Boolean,\n      default: false\n    },\n    buttonGroup: {\n      type: Boolean,\n      default: false\n    },\n    buttonVariant: {\n      default: null\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    },\n    form: {\n      default: void 0\n    },\n    id: {\n      default: void 0\n    },\n    inline: {\n      type: Boolean,\n      default: false\n    },\n    name: {\n      default: void 0\n    },\n    plain: {\n      type: Boolean,\n      default: false\n    },\n    required: {\n      type: Boolean,\n      default: void 0\n    },\n    reverse: {\n      type: Boolean,\n      default: false\n    },\n    size: {\n      default: void 0\n    },\n    state: {\n      type: [Boolean, null],\n      default: null\n    },\n    switch: {\n      type: Boolean,\n      default: false\n    },\n    uncheckedValue: {\n      type: [Array, Set, String, Boolean, Object, Number, null],\n      default: false\n    },\n    wrapperAttrs: {\n      default: void 0\n    },\n    inputClass: {\n      default: void 0\n    },\n    value: {\n      type: [String, Boolean, Array, Set, Object, Number, null],\n      default: true\n    }\n  }, {\n    \"modelValue\": {\n      type: [Array, Set, String, Boolean, Object, Number, null],\n      ...{\n        default: void 0\n      }\n    },\n    \"modelModifiers\": {},\n    \"indeterminate\": {\n      type: Boolean,\n      ...{\n        default: false\n      }\n    },\n    \"indeterminateModifiers\": {}\n  }),\n  emits: [\"update:modelValue\", \"update:indeterminate\"],\n  setup(__props, {\n    expose: __expose\n  }) {\n    const {\n      class: wrapperClass,\n      ...inputAttrs\n    } = useAttrs();\n    const _props = __props;\n    const props = useDefaults(_props, \"BFormCheckbox\");\n    const slots = useSlots();\n    const modelValue = useModel(__props, \"modelValue\");\n    const indeterminate = useModel(__props, \"indeterminate\");\n    const computedId = useId(() => props.id, \"form-check\");\n    const parentData = inject(checkboxGroupKey, null);\n    const input = useTemplateRef(\"input\");\n    const {\n      focused\n    } = useFocus(input, {\n      initialValue: props.autofocus\n    });\n    const hasDefaultSlot = computed(() => !isEmptySlot(slots.default));\n    const localValue = computed({\n      get: () => parentData ? parentData.modelValue.value : modelValue.value,\n      set: newVal => {\n        if (newVal === void 0) return;\n        indeterminate.value = false;\n        if (parentData !== null && Array.isArray(newVal)) {\n          parentData.modelValue.value = newVal;\n          return;\n        }\n        modelValue.value = newVal;\n      }\n    });\n    const computedRequired = computed(() => !!(props.name ?? (parentData == null ? void 0 : parentData.name.value)) && (props.required || (parentData == null ? void 0 : parentData.required.value)));\n    const isButtonGroup = computed(() => props.buttonGroup || ((parentData == null ? void 0 : parentData.buttons.value) ?? false));\n    const classesObject = computed(() => ({\n      plain: props.plain || ((parentData == null ? void 0 : parentData.plain.value) ?? false),\n      button: props.button || ((parentData == null ? void 0 : parentData.buttons.value) ?? false),\n      inline: props.inline || ((parentData == null ? void 0 : parentData.inline.value) ?? false),\n      reverse: props.reverse || ((parentData == null ? void 0 : parentData.reverse.value) ?? false),\n      switch: props.switch || ((parentData == null ? void 0 : parentData.switch.value) ?? false),\n      state: props.state === true || props.state === false ? props.state : (parentData == null ? void 0 : parentData.state.value) ?? null,\n      size: props.size ?? (parentData == null ? void 0 : parentData.size.value) ?? \"md\",\n      // This is where the true default is made\n      buttonVariant: props.buttonVariant ?? (parentData == null ? void 0 : parentData.buttonVariant.value) ?? \"secondary\",\n      // This is where the true default is made\n      hasDefaultSlot: hasDefaultSlot.value\n    }));\n    const wrapperClasses = getClasses(classesObject);\n    const computedWrapperClasses = computed(() => [wrapperClasses.value, wrapperClass]);\n    const inputClasses = getInputClasses(classesObject);\n    const computedInputClasses = computed(() => [inputClasses.value, props.inputClass]);\n    const labelClasses = getLabelClasses(classesObject);\n    __expose({\n      blur: () => {\n        focused.value = false;\n      },\n      element: input,\n      focus: () => {\n        focused.value = true;\n      }\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createBlock(_sfc_main$2, mergeProps({\n        skip: isButtonGroup.value\n      }, unref(props).wrapperAttrs, {\n        class: computedWrapperClasses.value\n      }), {\n        default: withCtx(() => {\n          var _a, _b, _c;\n          return [withDirectives(createElementVNode(\"input\", mergeProps({\n            id: unref(computedId),\n            ref_key: \"input\",\n            ref: input,\n            \"onUpdate:modelValue\": _cache[0] || (_cache[0] = $event => localValue.value = $event),\n            class: computedInputClasses.value,\n            type: \"checkbox\",\n            disabled: unref(props).disabled || ((_a = unref(parentData)) == null ? void 0 : _a.disabled.value),\n            required: computedRequired.value || void 0,\n            name: unref(props).name || ((_b = unref(parentData)) == null ? void 0 : _b.name.value),\n            form: unref(props).form || ((_c = unref(parentData)) == null ? void 0 : _c.form.value),\n            \"aria-label\": unref(props).ariaLabel,\n            \"aria-labelledby\": unref(props).ariaLabelledby,\n            \"aria-required\": computedRequired.value || void 0,\n            value: unref(props).value,\n            \"true-value\": unref(props).value,\n            \"false-value\": unref(props).uncheckedValue,\n            indeterminate: indeterminate.value || void 0\n          }, inputAttrs), null, 16, _hoisted_1$1), [[vModelCheckbox, localValue.value]]), hasDefaultSlot.value || unref(props).plain === false ? (openBlock(), createElementBlock(\"label\", {\n            key: 0,\n            for: unref(computedId),\n            class: normalizeClass(unref(labelClasses))\n          }, [renderSlot(_ctx.$slots, \"default\")], 10, _hoisted_2)) : createCommentVNode(\"\", true)];\n        }),\n        _: 3\n      }, 16, [\"skip\", \"class\"]);\n    };\n  }\n});\nconst _hoisted_1 = [\"id\"];\nconst _sfc_main = /* @__PURE__ */defineComponent({\n  __name: \"BFormCheckboxGroup\",\n  props: /* @__PURE__ */mergeModels({\n    ariaInvalid: {\n      type: [Boolean, String],\n      default: void 0\n    },\n    autofocus: {\n      type: Boolean,\n      default: false\n    },\n    buttonVariant: {\n      default: \"secondary\"\n    },\n    buttons: {\n      type: Boolean,\n      default: false\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    },\n    disabledField: {\n      default: \"disabled\"\n    },\n    form: {\n      default: void 0\n    },\n    id: {\n      default: void 0\n    },\n    name: {\n      default: void 0\n    },\n    options: {\n      default: () => []\n    },\n    plain: {\n      type: Boolean,\n      default: false\n    },\n    required: {\n      type: Boolean,\n      default: false\n    },\n    reverse: {\n      type: Boolean,\n      default: false\n    },\n    size: {\n      default: \"md\"\n    },\n    stacked: {\n      type: Boolean,\n      default: false\n    },\n    state: {\n      type: [Boolean, null],\n      default: null\n    },\n    switches: {\n      type: Boolean,\n      default: false\n    },\n    textField: {\n      default: \"text\"\n    },\n    validated: {\n      type: Boolean,\n      default: false\n    },\n    valueField: {\n      default: \"value\"\n    }\n  }, {\n    \"modelValue\": {\n      default: () => []\n    },\n    \"modelModifiers\": {}\n  }),\n  emits: [\"update:modelValue\"],\n  setup(__props, {\n    expose: __expose\n  }) {\n    const _props = __props;\n    const props = useDefaults(_props, \"BFormCheckboxGroup\");\n    const modelValue = useModel(__props, \"modelValue\");\n    const computedId = useId(() => props.id, \"checkbox\");\n    const computedName = useId(() => props.name, \"checkbox\");\n    const element = useTemplateRef(\"element\");\n    const {\n      focused\n    } = useFocus(element, {\n      initialValue: props.autofocus\n    });\n    provide(checkboxGroupKey, {\n      modelValue,\n      switch: toRef(() => props.switches),\n      buttonVariant: toRef(() => props.buttonVariant),\n      form: toRef(() => props.form),\n      name: computedName,\n      state: toRef(() => props.state),\n      plain: toRef(() => props.plain),\n      size: toRef(() => props.size),\n      inline: toRef(() => !props.stacked),\n      reverse: toRef(() => props.reverse),\n      required: toRef(() => props.required),\n      buttons: toRef(() => props.buttons),\n      disabled: toRef(() => props.disabled)\n    });\n    const normalizeOptions = computed(() => props.options.map(el => typeof el === \"string\" || typeof el === \"number\" ? {\n      value: el,\n      disabled: props.disabled,\n      text: el.toString()\n    } : {\n      value: el[props.valueField],\n      disabled: el[props.disabledField],\n      ...(el.props ? el.props : {}),\n      text: el[props.textField]\n    }));\n    const classesObject = computed(() => ({\n      required: props.required,\n      ariaInvalid: props.ariaInvalid,\n      state: props.state,\n      validated: props.validated,\n      buttons: props.buttons,\n      stacked: props.stacked,\n      size: props.size\n    }));\n    const computedAttrs = getGroupAttr(classesObject);\n    const computedClasses = getGroupClasses(classesObject);\n    __expose({\n      blur: () => {\n        focused.value = false;\n      },\n      focus: () => {\n        focused.value = true;\n      }\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(\"div\", mergeProps(unref(computedAttrs), {\n        id: unref(computedId),\n        ref_key: \"element\",\n        ref: element,\n        role: \"group\",\n        class: [unref(computedClasses), \"bv-no-focus-ring\"],\n        tabindex: \"-1\"\n      }), [renderSlot(_ctx.$slots, \"first\"), (openBlock(true), createElementBlock(Fragment, null, renderList(normalizeOptions.value, (item, index) => {\n        return openBlock(), createBlock(_sfc_main$1, mergeProps({\n          key: index,\n          ref_for: true\n        }, item), {\n          default: withCtx(() => [renderSlot(_ctx.$slots, \"option\", mergeProps({\n            ref_for: true\n          }, item), () => [createTextVNode(toDisplayString(item.text), 1)])]),\n          _: 2\n        }, 1040);\n      }), 128)), renderSlot(_ctx.$slots, \"default\")], 16, _hoisted_1);\n    };\n  }\n});\nexport { _sfc_main$1 as _, _sfc_main as a };","map":{"version":3,"names":["class","wrapperClass","inputAttrs","useAttrs","_props","__props","props","useDefaults","slots","useSlots","modelValue","useModel","indeterminate","computedId","useId","id","parentData","inject","checkboxGroupKey","input","useTemplateRef","focused","useFocus","initialValue","autofocus","hasDefaultSlot","computed","isEmptySlot","default","localValue","get","value","set","newVal","Array","isArray","computedRequired","name","required","isButtonGroup","buttonGroup","buttons","classesObject","plain","button","inline","reverse","switch","state","size","buttonVariant","wrapperClasses","getClasses","computedWrapperClasses","inputClasses","getInputClasses","computedInputClasses","inputClass","labelClasses","getLabelClasses","__expose","blur","element","focus","computedName","provide","toRef","switches","form","stacked","disabled","normalizeOptions","options","map","el","text","toString","valueField","disabledField","textField","ariaInvalid","validated","computedAttrs","getGroupAttr","computedClasses","getGroupClasses"],"sources":["../src/components/BFormCheckbox/BFormCheckbox.vue","../src/components/BFormCheckbox/BFormCheckboxGroup.vue"],"sourcesContent":["<template>\n  <ConditionalWrapper\n    :skip=\"isButtonGroup\"\n    v-bind=\"props.wrapperAttrs\"\n    :class=\"computedWrapperClasses\"\n  >\n    <input\n      :id=\"computedId\"\n      ref=\"input\"\n      v-model=\"localValue\"\n      :class=\"computedInputClasses\"\n      type=\"checkbox\"\n      :disabled=\"props.disabled || parentData?.disabled.value\"\n      :required=\"computedRequired || undefined\"\n      :name=\"props.name || parentData?.name.value\"\n      :form=\"props.form || parentData?.form.value\"\n      :aria-label=\"props.ariaLabel\"\n      :aria-labelledby=\"props.ariaLabelledby\"\n      :aria-required=\"computedRequired || undefined\"\n      :value=\"props.value\"\n      :true-value=\"props.value\"\n      :false-value=\"props.uncheckedValue\"\n      :indeterminate=\"indeterminate || undefined\"\n      v-bind=\"inputAttrs\"\n    />\n    <label v-if=\"hasDefaultSlot || props.plain === false\" :for=\"computedId\" :class=\"labelClasses\">\n      <slot />\n    </label>\n  </ConditionalWrapper>\n</template>\n\n<script setup lang=\"ts\">\nimport {useFocus} from '@vueuse/core'\nimport {computed, inject, useAttrs, useTemplateRef} from 'vue'\nimport {getClasses, getInputClasses, getLabelClasses} from '../../composables/useFormCheck'\nimport type {BFormCheckboxProps} from '../../types/ComponentProps'\nimport {checkboxGroupKey} from '../../utils/keys'\nimport ConditionalWrapper from '../ConditionalWrapper.vue'\nimport {isEmptySlot} from '../../utils/dom'\nimport {useDefaults} from '../../composables/useDefaults'\nimport type {CheckboxValue} from '../../types/CheckboxTypes'\nimport {useId} from '../../composables/useId'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst {class: wrapperClass, ...inputAttrs} = useAttrs()\n\nconst _props = withDefaults(\n  defineProps<Omit<BFormCheckboxProps, 'modelValue' | 'indeterminate'>>(),\n  {\n    wrapperAttrs: undefined,\n    inputClass: undefined,\n    ariaLabel: undefined,\n    ariaLabelledby: undefined,\n    autofocus: false,\n    button: false,\n    buttonGroup: false,\n    buttonVariant: null,\n    disabled: false,\n    form: undefined,\n    id: undefined,\n    inline: false,\n    name: undefined,\n    plain: false,\n    required: undefined,\n    reverse: false,\n    size: undefined,\n    state: null,\n    switch: false,\n    uncheckedValue: false,\n    value: true,\n  }\n)\nconst props = useDefaults(_props, 'BFormCheckbox')\n\nconst slots = defineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst modelValue = defineModel<BFormCheckboxProps['modelValue']>({\n  default: undefined,\n})\nconst indeterminate = defineModel<Exclude<BFormCheckboxProps['indeterminate'], undefined>>(\n  'indeterminate',\n  {\n    default: false,\n  }\n)\n\nconst computedId = useId(() => props.id, 'form-check')\n\nconst parentData = inject(checkboxGroupKey, null)\n\nconst input = useTemplateRef<HTMLElement>('input')\n\nconst {focused} = useFocus(input, {\n  initialValue: props.autofocus,\n})\n\nconst hasDefaultSlot = computed(() => !isEmptySlot(slots.default))\n\nconst localValue = computed({\n  get: () => (parentData ? parentData.modelValue.value : modelValue.value),\n  set: (newVal) => {\n    if (newVal === undefined) return\n    // Indeterminate is implicitly cleared when the checked state is changed to any value\n    //  by the user.  We reflect that here by setting our indetermiate model to false\n    //  which will emit the indeterminate event to the parent\n    indeterminate.value = false\n    if (parentData !== null && Array.isArray(newVal)) {\n      // The type cast isn't perfect. Array.isArray detects CheckboxValue.unknown[],\n      // but since it's parentData, it should always be CheckboxValue[]\n      // It doesn't quite work when props.value is an [], but this is more of a Vue issue\n      parentData.modelValue.value = newVal as CheckboxValue[]\n      return\n    }\n    modelValue.value = newVal as CheckboxValue\n  },\n})\n\nconst computedRequired = computed(\n  () => !!(props.name ?? parentData?.name.value) && (props.required || parentData?.required.value)\n)\n\nconst isButtonGroup = computed(() => props.buttonGroup || (parentData?.buttons.value ?? false))\n\nconst classesObject = computed(() => ({\n  plain: props.plain || (parentData?.plain.value ?? false),\n  button: props.button || (parentData?.buttons.value ?? false),\n  inline: props.inline || (parentData?.inline.value ?? false),\n  reverse: props.reverse || (parentData?.reverse.value ?? false),\n  switch: props.switch || (parentData?.switch.value ?? false),\n  state:\n    props.state === true || props.state === false ? props.state : (parentData?.state.value ?? null),\n  size: props.size ?? parentData?.size.value ?? 'md', // This is where the true default is made\n  buttonVariant: props.buttonVariant ?? parentData?.buttonVariant.value ?? 'secondary', // This is where the true default is made\n  hasDefaultSlot: hasDefaultSlot.value,\n}))\nconst wrapperClasses = getClasses(classesObject)\nconst computedWrapperClasses = computed(() => [wrapperClasses.value, wrapperClass])\nconst inputClasses = getInputClasses(classesObject)\nconst computedInputClasses = computed(() => [inputClasses.value, props.inputClass])\nconst labelClasses = getLabelClasses(classesObject)\n\ndefineExpose({\n  blur: () => {\n    focused.value = false\n  },\n  element: input,\n  focus: () => {\n    focused.value = true\n  },\n})\n</script>\n","<template>\n  <div\n    v-bind=\"computedAttrs\"\n    :id=\"computedId\"\n    ref=\"element\"\n    role=\"group\"\n    :class=\"computedClasses\"\n    class=\"bv-no-focus-ring\"\n    tabindex=\"-1\"\n  >\n    <slot name=\"first\" />\n    <BFormCheckbox v-for=\"(item, index) in normalizeOptions\" :key=\"index\" v-bind=\"item\">\n      <slot name=\"option\" v-bind=\"item\">\n        {{ item.text }}\n      </slot>\n    </BFormCheckbox>\n    <slot />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, provide, toRef, useTemplateRef} from 'vue'\nimport BFormCheckbox from './BFormCheckbox.vue'\nimport {checkboxGroupKey} from '../../utils/keys'\nimport {useFocus} from '@vueuse/core'\nimport type {BFormCheckboxGroupProps} from '../../types/ComponentProps'\nimport {useDefaults} from '../../composables/useDefaults'\nimport {useId} from '../../composables/useId'\nimport {getGroupAttr, getGroupClasses} from '../../composables/useFormCheck'\n\nconst _props = withDefaults(defineProps<Omit<BFormCheckboxGroupProps, 'modelValue'>>(), {\n  ariaInvalid: undefined,\n  autofocus: false,\n  buttonVariant: 'secondary',\n  buttons: false,\n  disabled: false,\n  disabledField: 'disabled',\n  form: undefined,\n  id: undefined,\n  name: undefined,\n  options: () => [],\n  plain: false,\n  required: false,\n  reverse: false,\n  size: 'md',\n  stacked: false,\n  state: null,\n  switches: false,\n  textField: 'text',\n  validated: false,\n  valueField: 'value',\n})\nconst props = useDefaults(_props, 'BFormCheckboxGroup')\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  first?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  option: (props: Record<string, unknown>) => any\n}>()\n\nconst modelValue = defineModel<Exclude<BFormCheckboxGroupProps['modelValue'], undefined>>({\n  default: () => [],\n})\n\nconst computedId = useId(() => props.id, 'checkbox')\nconst computedName = useId(() => props.name, 'checkbox')\n\nconst element = useTemplateRef<HTMLElement>('element')\n\nconst {focused} = useFocus(element, {\n  initialValue: props.autofocus,\n})\n\nprovide(checkboxGroupKey, {\n  modelValue,\n  switch: toRef(() => props.switches),\n  buttonVariant: toRef(() => props.buttonVariant),\n  form: toRef(() => props.form),\n  name: computedName,\n  state: toRef(() => props.state),\n  plain: toRef(() => props.plain),\n  size: toRef(() => props.size),\n  inline: toRef(() => !props.stacked),\n  reverse: toRef(() => props.reverse),\n  required: toRef(() => props.required),\n  buttons: toRef(() => props.buttons),\n  disabled: toRef(() => props.disabled),\n})\n\nconst normalizeOptions = computed(() =>\n  props.options.map((el) =>\n    typeof el === 'string' || typeof el === 'number'\n      ? {\n          value: el,\n          disabled: props.disabled,\n          text: el.toString(),\n        }\n      : {\n          value: el[props.valueField] as string | number | undefined,\n          disabled: el[props.disabledField] as boolean | undefined,\n          ...(el.props ? el.props : {}),\n          text: el[props.textField] as string | undefined,\n        }\n  )\n)\n\nconst classesObject = computed(() => ({\n  required: props.required,\n  ariaInvalid: props.ariaInvalid,\n  state: props.state,\n  validated: props.validated,\n  buttons: props.buttons,\n  stacked: props.stacked,\n  size: props.size,\n}))\nconst computedAttrs = getGroupAttr(classesObject)\nconst computedClasses = getGroupClasses(classesObject)\n\ndefineExpose({\n  blur: () => {\n    focused.value = false\n  },\n  focus: () => {\n    focused.value = true\n  },\n})\n</script>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}